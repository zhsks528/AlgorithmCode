---
title: "백준알고리즘 - 2529. 부등호"
date: "2020-10-08T16:27:33:122Z"
category: "ps"
emoji: "🌄"
---

## 백준알고리즘 - 2529. 부등호

- 관련된 알고리즘 : 그래프 이론, 브루트포스 알고리즘, 백트래킹, 위상 정렬

### 문제

모든 자리가 1로만 이루어져있는 두 자연수 A와 B가 주어진다. 이때, A와 B의 최대 공약수를 구하는 프로그램을 작성하시오.

예를 들어, A가 111이고, B가 1111인 경우에 A와 B의 최대공약수는 1이고, A가 111이고, B가 111111인 경우에는 최대공약수가 111이다.

### 입력

첫째 줄에 두 자연수 A와 B를 이루는 1의 개수가 주어진다. 입력되는 수는 2^63보다 작은 자연수이다.

### 출력

첫째 줄에 A와 B의 최대공약수를 출력한다. 정답은 천만 자리를 넘지 않는다.

### 예제 1

```
Input : 3 4
Output : 1
```

### 예제 2

```
Input : 3 6
Output : 111
```

### 예제 3

```
Input : 500000000000000000 500000000000000002
Output : 11
```


### 해결

```python
# 52분 혼자해결 X

# 1. 하나의 숫자를 구하기 위해서 입력으로 주어진 길이(N)+1 만큼 재귀 함수를 호출해야 한다. 올바른 부등식은 숫자 개수가 부등호 개수보다 1개 더 많다.
# 2. 재귀 함수 종료 조건 : 숫자 개수(길이) == N+1
# 3. 수를 중복하여 사용할 수 없으므로, check 배열을 별도로 만들어서 사용 여부를 확인해야 한다.
# 4. 재귀 함수를 호출하기 전에, 다음 숫자가 부등식에 맞는지 살펴봐야 한다.
# 4-1. 예를 들어, 주어진 부등호가 < > > 라면, 0 < 3 > 2 > 1은 가능하다. 
# 4-2. 하지만 3 < 2 > 1 > 0은 불가능하다. 이런 경우, 3 < 2부터 틀린 부등식이므로, 이 뒤로는 함수를 호출할 필요가 없다.
# 5. 재귀 함수 호출을 0부터 9까지 순서대로 부르므로, 정답의 최솟값은 처음 호출된 값이며, 최댓값은 마지막에 호출된 값이다.

n = int(input())
op = input().split()
check = [False] * 10
mx, mn = "", ""

# 4-1, 4-2
def possible(i, j, k):
    if k == '<':
        return i < j
    
    if k == '>':
        return i > j
    
    return True

# 1
def solve(cnt, s):
    global mx, mn
    
    # 2
    if cnt == n+1:
        
        # 5
        if not len(mn):
            mn = s
        else:
            mx = s
            
        return
    
    for i in range(10):
        # 3
        if not check[i]:
            # 4
            if cnt == 0 or possible(s[-1], str(i), op[cnt-1]):
                check[i] = True
                solve(cnt+1, s+str(i))
                check[i] = False

solve(0, "")
print("%s\n%s" % (mx, mn))
```

### 설명

1. 하나의 숫자를 구하기 위해서 입력으로 주어진 길이(N)+1 만큼 재귀 함수를 호출해야 한다. 올바른 부등식은 숫자 개수가 부등호 개수보다 1개 더 많다.
2. 재귀 함수 종료 조건 : 숫자 개수(길이) == N+1
3. 수를 중복하여 사용할 수 없으므로, check 배열을 별도로 만들어서 사용 여부를 확인해야 한다.
4. 재귀 함수를 호출하기 전에, 다음 숫자가 부등식에 맞는지 살펴봐야 한다.
   1. 예를 들어, 주어진 부등호가 < > > 라면, 0 < 3 > 2 > 1은 가능하다. 
   2. 하지만 3 < 2 > 1 > 0은 불가능하다. 이런 경우, 3 < 2부터 틀린 부등식이므로, 이 뒤로는 함수를 호출할 필요가 없다.
5. 재귀 함수 호출을 0부터 9까지 순서대로 부르므로, 정답의 최솟값은 처음 호출된 값이며, 최댓값은 마지막에 호출된 값이다.


### 출처

- https://www.acmicpc.net/problem/2529

### 참조

- [코드 및 설명](https://rebas.kr/755)