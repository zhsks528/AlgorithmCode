## 백준알고리즘 -1949. 우수 마을

- 관련된 알고리즘 : 다이나믹 프로그래밍, 트리, 트리에서의 다이나믹 프로그래밍

### 문제

N개의 마을로 이루어진 나라가 있다. 편의상 마을에는 1부터 N까지 번호가 붙어 있다고 하자. 이 나라는 트리(Tree) 구조로 이루어져 있다. 즉 마을과 마을 사이를 직접 잇는 N-1개의 길이 있으며, 각 길은 방향성이 없어서 A번 마을에서 B번 마을로 갈 수 있다면 B번 마을에서 A번 마을로 갈 수 있다. 또, 모든 마을은 연결되어 있다. 두 마을 사이에 직접 잇는 길이 있을 때, 두 마을이 인접해 있다고 한다.

이 나라의 주민들에게 성취감을 높여 주기 위해, 다음 세 가지 조건을 만족하면서 N개의 마을 중 몇 개의 마을을 '우수 마을'로 선정하려고 한다.

1. '우수 마을'로 선정된 마을 주민 수의 총 합을 최대로 해야 한다.
2. 마을 사이의 충돌을 방지하기 위해서, 만일 두 마을이 인접해 있으면 두 마을을 모두 '우수 마을'로 선정할 수는 없다. 즉 '우수 마을'끼리는 서로 인접해 있을 수 없다.
3. 선정되지 못한 마을에 경각심을 불러일으키기 위해서, '우수 마을'로 선정되지 못한 마을은 적어도 하나의 '우수 마을'과는 인접해 있어야 한다.

각 마을 주민 수와 마을 사이의 길에 대한 정보가 주어졌을 때, 주어진 조건을 만족하도록 '우수 마을'을 선정하는 프로그램을 작성하시오.

### 입력

첫째 줄에 정수 N이 주어진다. (1≤N≤10,000) 둘째 줄에는 마을 주민 수를 나타내는 N개의 자연수가 빈칸을 사이에 두고 주어진다. 1번 마을부터 N번 마을까지 순서대로 주어지며, 주민 수는 10,000 이하이다. 셋째 줄부터 N-1개 줄에 걸쳐서 인접한 두 마을의 번호가 빈칸을 사이에 두고 주어진다.

### 출력

첫째 줄에 '우수 마을'의 주민 수의 총 합을 출력한다.

### 예제

```
Input : 7
        1000 3000 4000 1000 2000 2000 7000
        1 2
        2 3
        4 3
        4 5
        6 2
        6 7
Output : 14000
```

### 해결

```python
# 33분
# 도움&참조 : O

# 1. 입력값을 이용하여 그래프를 생성한다.
# 2. 방문한 노드와 방문하지 않은 노드를 저장할 DP를 생성한다.
# 3. DFS를 이용하여 방문한 노드와 방문하지 않은 노드의 인구 수를 구한다.
# 4. 가장 큰 값을 출력한다.

import sys

input = sys.stdin.readline
sys.setrecursionlimit(20000)


def dfs(v):
    visited[v] = True
    dp[v][0] = vilage[v]
    dp[v][1] = 0

    for i in graph[v]:
        if not visited[i]:
            dfs(i)

            # dp[v][0] = 방문한 노드
            # dp[v][1] = 방문하지 않은 노드
            dp[v][0] += dp[i][1]
            dp[v][1] += max(dp[i][0], dp[i][1])


# 1
n = int(input())
vilage = [0] + list(map(int, input().split()))
graph = [[] for _ in range(n+1)]
visited = [False] * (n+1)

for _ in range(n-1):
    node_a, node_b = map(int, input().split())

    graph[node_a].append(node_b)
    graph[node_b].append(node_a)

# 2
dp = [[0, 0] for _ in range(n+1)]

# 3
dfs(1)

# 4
print(max(dp[1][1], dp[1][0]))
```

### 설명

1. 입력값을 이용하여 그래프를 생성한다.

2. 방문한 노드와 방문하지 않은 노드를 저장할 DP를 생성한다.

3. DFS를 이용하여 방문한 노드와 방문하지 않은 노드의 인구 수를 구한다.

4. 가장 큰 값을 출력한다.

### 참조

- [코드 및 설명](https://developmentdiary.tistory.com/454)

### 출처

- https://www.acmicpc.net/problem/1949
