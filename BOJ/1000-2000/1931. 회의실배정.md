---
title: "백준알고리즘 - 1931. 회의실배정"
date: "2020-07-30T22:48:13.312Z"
category: "algorithm"
emoji: "🤝"
---

## 백준알고리즘 - 1931. 회의실배정

- 관련된 알고리즘 : 탐욕 알고리즘

### 문제

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

### 입력

첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

### 출력

첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

### 예제

```
Input : 11
        1 4
        3 5
        0 6
        5 7
        3 8
        5 9
        6 10
        8 11
        8 12
        2 13
        12 14
Output : 4
```

### 해결 

```python
n = int(input())
array = [[0]*2 for _ in range(n)]

for i in range(n):
    start, end = map(int, input().split())
    array[i][0] = start
    array[i][1] = end

# 1. 종료 시간, 시작 시간을 기준으로 정렬을 한다.
array.sort(key = lambda x : (x[1], x[0]))

count = 1
end_time = array[0][1]

# 2. 종료시간보다 바로 다음으로 큰 시작시간을 찾아서 종료시간을 바꾼다.
for i in range(1, n):
    if array[i][0] >= end_time:
        count += 1
        end_time = array[i][1]

print(count)
```

### 힌트

(1,4), (5,7), (8,11), (12,14) 를 이용할 수 있다.

### 설명

1. 끝나는 시간, 시작하는 시간을 기준으로 정렬을 한다.
2. 종료시간보다 바로 다음으로 큰 시작시간을 찾아서 종료시간을 바꾼다.

### 출처

- https://www.acmicpc.net/problem/1931
